services:
  database:
    container_name: database
    image: postgres
    environment:
      POSTGRES_USER: $PG_USER
      POSTGRES_PASSWORD: $PG_PASSWORD
      POSTGRES_DB: $PG_DB
      PGPORT: $PG_PORT
    volumes:
      - database-data:/var/lib/postgresql/data/
    ports:
      - $PG_PORT:$PG_PORT
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $PG_USER -d $PG_DB"]
      interval: 30s
      timeout: 10s
      retries: 5
    
  pgadmin:
    image: dpage/pgadmin4
    container_name: pgadmin4_container
    restart: always
    ports:
      - "8888:80"
    environment:
      PGADMIN_DEFAULT_EMAIL: user-name@domain-name.com
      PGADMIN_DEFAULT_PASSWORD: strong-password
    volumes:
      - pgadmin-data:/var/lib/pgadmin
  
  resolver_consumer:
    image: consumer:latest
    command: ./consumer --mode resolver
    environment:
      AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
      AWS_REGION: $AWS_REGION
      AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
      CONSUMER_TYPE: $CONSUMER_TYPE
      DATABASE_URL: $DATABASE_URL
      ENS_CONTRACT_ADDRESS: $ENS_CONTRACT_ADDRESS
      IMAGE_GUARD_URL: $IMAGE_GUARD_URL
      IPFS_GATEWAY_URL: $IPFS_GATEWAY_URL
      IPFS_UPLOAD_URL: $IPFS_UPLOAD_URL
      LOCALSTACK_URL: $LOCALSTACK_URL
      PINATA_API_JWT: $PINATA_API_JWT
      PINATA_GATEWAY_TOKEN: $PINATA_GATEWAY_TOKEN
      PG_MIN_CONNECTIONS: $PG_MIN_CONNECTIONS
      RESOLVER_QUEUE_URL: $RESOLVER_QUEUE_URL
      RPC_URL_BASE_MAINNET: $RPC_URL_BASE_MAINNET
      RPC_URL_MAINNET: $RPC_URL_MAINNET
      RUST_LOG: $RUST_LOG
    restart: always
    depends_on:
      sqs:
        condition: service_healthy
    volumes:
      - ~/.aws/:/root/.aws:ro
    deploy:
      replicas: 3
    
  decoded_consumer:
    container_name: decoded_consumer
    image: consumer:latest
    command: ./consumer --mode decoded
    environment:
      AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
      AWS_REGION: $AWS_REGION
      AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
      CONSUMER_TYPE: $CONSUMER_TYPE
      DATABASE_URL: $DATABASE_URL
      DECODED_LOGS_QUEUE_URL: $DECODED_LOGS_QUEUE_URL
      INTUITION_CONTRACT_ADDRESS: $INTUITION_CONTRACT_ADDRESS
      LOCALSTACK_URL: $LOCALSTACK_URL
      PG_MIN_CONNECTIONS: $PG_MIN_CONNECTIONS
      RESOLVER_QUEUE_URL: $RESOLVER_QUEUE_URL
      RPC_URL_BASE_MAINNET: $RPC_URL_BASE_MAINNET
      RUST_LOG: $RUST_LOG
    restart: always
    depends_on:
      sqs:
        condition: service_healthy
    volumes:
      - ~/.aws/:/root/.aws:ro
    
  raw_consumer:
    container_name: raw_consumer
    image: consumer:latest
    command: ./consumer --mode raw
    environment:
      AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
      AWS_REGION: $AWS_REGION
      AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
      CONSUMER_TYPE: $CONSUMER_TYPE
      DATABASE_URL: $DATABASE_URL
      DECODED_LOGS_QUEUE_URL: $DECODED_LOGS_QUEUE_URL
      INDEXING_SOURCE: $INDEXING_SOURCE
      LOCALSTACK_URL: $LOCALSTACK_URL
      PG_MIN_CONNECTIONS: $PG_MIN_CONNECTIONS
      RAW_CONSUMER_QUEUE_URL: $RAW_CONSUMER_QUEUE_URL
      RPC_URL_BASE_MAINNET: $RPC_URL_BASE_MAINNET
      RPC_URL_MAINNET: $RPC_URL_MAINNET
      RUST_LOG: $RUST_LOG
    restart: always
    depends_on:
      sqs:
        condition: service_healthy
    volumes:
      - ~/.aws/:/root/.aws:ro

  sqs:
    container_name: sqs
    image: localstack/localstack:latest
    ports:
      # - "127.0.0.1:53:53"
      # - "127.0.0.1:53:53/udp"
      # - "127.0.0.1:443:443"
      - "127.0.0.1:4566:4566"
      - "127.0.0.1:4571:4571"
    volumes:
      - ./consumer/devops/localstack-setup.sh:/etc/localstack/init/ready.d/script.sh
    environment:
    # Set an env var to use later in the code
      - ALLOW_NONSTANDARD_REGIONS=1
      - AWS_DEFAULT_REGION=us-east-1
      - AWS_ENDPOINT=http://localstack:4566
      - DEBUG=1
      - DOCKER_HOST=0.0.0.0
      - EXTRA_CORS_ALLOWED_ORIGINS=app://.
      - HOSTNAME_EXTERNAL=localstack
      - RUST_LOG=debug
      - SERVICES=sqs
    
  api:
    container_name: api
    image: image-guard:latest
    environment:
      API_PORT: 3000
      DATABASE_URL: $DATABASE_URL
      HF_TOKEN: $HF_TOKEN
      IPFS_GATEWAY_URL: $IPFS_GATEWAY_URL
      IPFS_UPLOAD_URL: $IPFS_UPLOAD_URL
      PINATA_API_JWT: $PINATA_API_JWT
      RUST_LOG: $RUST_LOG
    ports:
      - 3000:3000
    

  safe-content:
    container_name: safe-content
    image: steelcityamir/safe-content-ai:latest
    ports:
      - 8000:8000
    
  graphql-engine:
    container_name: graphql-engine
    image: hasura/graphql-engine:v2.44.0
    ports:
      - '8080:8080'
    restart: always
    environment:
      HASURA_GRAPHQL_METADATA_DATABASE_URL: postgres://testuser:test@database:$PG_PORT/storage
      HASURA_GRAPHQL_ENABLE_CONSOLE: 'true'
      HASURA_GRAPHQL_UNAUTHORIZED_ROLE: 'anonymous'
      HASURA_GRAPHQL_DEV_MODE: 'true'
      HASURA_GRAPHQL_ENABLED_LOG_TYPES: startup, http-log, webhook-log, websocket-log, query-log
      HASURA_GRAPHQL_ADMIN_SECRET: $HASURA_GRAPHQL_ADMIN_SECRET
      HASURA_GRAPHQL_STRINGIFY_NUMERIC_TYPES: 'true'
      PINATA_AUTH: Bearer $PINATA_API_JWT
    depends_on:
      database:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]
      interval: 30s
      timeout: 10s
      retries: 5
    
  ipfs:
    container_name: ipfs
    image: ipfs/kubo:latest
    restart: always
    ports:
      - 4001:4001
      - 4002:4002/udp
      - 4003:4003
      - 5001:5001
      - 8081:8080
    environment:
      IPFS_PATH: /data/ipfs
      PINATA_API_JWT: $PINATA_API_JWT
    volumes:
      - ipfs_data:/data/ipfs
    entrypoint: /bin/sh
    command: >
      -c "
        # Initialize IPFS if not initialized
        if [ ! -f /data/ipfs/config ]; then
          ipfs init;
        fi;

        # Configure IPFS to listen on all interfaces for API and Gateway
        ipfs config Addresses.API /ip4/0.0.0.0/tcp/5001;
        ipfs config Addresses.Gateway /ip4/0.0.0.0/tcp/8080;

        # Add Pinata as a remote pinning service
        ipfs pin remote service add Pinata https://api.pinata.cloud/psa $PINATA_API_JWT;

        # Configure Pinata gateway and use subdomains
        ipfs config --json Gateway.PublicGateways '{\"localhost\": {\"UseSubdomains\": false,\"Paths\": [\"/ipfs\", \"/ipns\"]},\"ipfs\": {\"UseSubdomains\": false,\"Paths\": [\"/ipfs\", \"/ipns\"]}}';

        # Set Pinata as the default remote pinning service
        ipfs config --json Pinning.RemoteServices '[\"Pinata\"]';

        # Configure policy to automatically pin all files to Pinata (MFS policy)
        ipfs config --json Pinning.RemoteServices.Pinata.Policies '{\"MFS\":{\"Enable\": false,\"PinName\": \"\",\"RepinInterval\": \"1m\"}}';

        # Add Peering to Pinata (optional)
        ipfs config --json Peering.Peers '[{\"ID\": \"Qma8ddFEQWEU8ijWvdxXm3nxU7oHsRtCykAaVz8WUYhiKn\", \"Addrs\": [\"/dnsaddr/bitswap.pinata.cloud\"]}]';

        # Start the IPFS daemon
        exec ipfs daemon --migrate=true --agent-version-suffix=docker
      "

  substreams-sink:
    container_name: substreams-sink
    image: substreams-sink:latest
    restart: always
    entrypoint: ["./substreams-sink"]
    environment:
      LOCALSTACK_URL: $LOCALSTACK_URL
      AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
      AWS_REGION: $AWS_REGION
      AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
      DATABASE_URL: $DATABASE_URL
      RAW_CONSUMER_QUEUE_URL: $RAW_CONSUMER_QUEUE_URL
      SUBSTREAMS_ENDPOINT: $SUBSTREAMS_ENDPOINT
      SUBSTREAMS_PACKAGE: $SUBSTREAMS_PACKAGE
      SUBSTREAMS_MODULE: $SUBSTREAMS_MODULE
      SUBSTREAMS_START_BLOCK: $SUBSTREAMS_START_BLOCK
      SUBSTREAMS_API_TOKEN: $SUBSTREAMS_API_TOKEN
    command: ["$SUBSTREAMS_ENDPOINT", "$SUBSTREAMS_PACKAGE", "$SUBSTREAMS_MODULE", "$SUBSTREAMS_START_BLOCK:"]
    depends_on:
      sqs:
        condition: service_healthy
      hasura-migrations:
        condition: service_started
    volumes:
      - substreams-sink-data:/data

  hasura-migrations:
    container_name: hasura-migrations
    image: leboiko/hasura-migrations:0.1.0
    environment:
      HASURA_GRAPHQL_ENDPOINT: $HASURA_GRAPHQL_ENDPOINT
      HASURA_GRAPHQL_ADMIN_SECRET: $HASURA_GRAPHQL_ADMIN_SECRET
    depends_on:
      database:
        condition: service_healthy
      graphql-engine:
        condition: service_healthy
    restart: "no"

  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
    depends_on:
      - api

networks:
  intuition-be:
    driver: bridge
    
volumes:
  sqs:
  raw_consumer:
  decoded_consumer:
  database-data:
  pgadmin-data:
  ipfs_data:
  substreams-sink-data: